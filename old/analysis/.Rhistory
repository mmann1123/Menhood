assess.quiver.heights <- function(quiver.list, thresh, surfer)
{
if(all(quiver.list) > thresh)
{
cat("YEWWWW!",surfer, "will be able to ride boards in this quiver\n")
}
else
{
cat("Bummer!", surfer, "will not be able to ride boards in this quiver\n")
}
}
assess.quiver.heights(board.heights,5,"Lil Max")
assess.quiver.heights(board.heights,1,"Lil Max")
ssess.quiver.heights <- function(quiver.list, thresh, surfer)
{
if(all(quiver.list > thresh))
{
cat("YEWWWW!",surfer, "will be able to ride boards in this quiver\n")
}
else
{
cat("Bummer!", surfer, "will not be able to ride boards in this quiver\n")
}
}
assess.quiver.heights(board.heights,1,"Lil Max")
assess.quiver.heights <- function(quiver.list, thresh, surfer)
{
if(all(quiver.list > thresh)) cat("YEWWWW!",surfer, "will be able to ride boards in this quiver\n"))
else
{
cat("Bummer!", surfer, "will not be able to ride boards in this quiver\n")
}
}
assess.quiver.heights(board.heights,1,"Lil Max")
assess.quiver.heights(board.heights,10,"Lil Max")
if(all(quiver.list < thresh)) cat("YEWWWW!",surfer, "will be able to ride boards in this quiver\n"))
gcd2 <- function(x)
{
# make divisor the minimum of the two numbers
divisor <- min(a,60)
# save divisor as divisor to print to use later.
divisor.to.print <- divisor
cat("The current divisor is: ",divisor.to.print)
# make the dividend the maximum of the two numbers
dividend <- max(a,60)
repeat
{
# save the remainder of dividend divided by divisor
remainder <- dividend %% divisor
# set the dividend as the divisor
dividend <- divisor
# make the divisor the remainder
divisor <- remainder
# if the remainder is not zero, then break, else keep going
if (remainder == 0) { cat("The greatest common divisor is: ",divisor.to.print)} break
}
}
gcd2(3)
gcd2 <- function(x)
{
# make divisor the minimum of the two numbers
divisor <- min(a,60)
# save divisor as divisor to print to use later.
divisor.to.print <- divisor
cat("The current divisor is: ",divisor.to.print)
# make the dividend the maximum of the two numbers
dividend <- max(a,60)
repeat
{
# save the remainder of dividend divided by divisor
remainder <- dividend %% divisor
# set the dividend as the divisor
dividend <- divisor
# make the divisor the remainder
divisor <- remainder
# if the remainder is not zero, then break, else keep going
if (remainder == 0) { cat("The greatest common divisor is: ",divisor.to.print)} break
}
gcd2 <- function(x)
{
# make divisor the minimum of the two numbers
divisor <- min(a,60)
# save divisor as divisor to print to use later.
divisor.to.print <- divisor
cat("The current divisor is: ",divisor.to.print)
# make the dividend the maximum of the two numbers
dividend <- max(a,60)
repeat
{
# save the remainder of dividend divided by divisor
remainder <- dividend %% divisor
# set the dividend as the divisor
dividend <- divisor
# make the divisor the remainder
divisor <- remainder
# if the remainder is not zero, then break, else keep going
if (remainder == 0)
{
cat("The greatest common divisor is: ",divisor.to.print)
}  break
gcd2 <- function(x)
{
# make divisor the minimum of the two numbers
divisor <- min(a,60)
# save divisor as divisor to print to use later.
divisor.to.print <- divisor
cat("The current divisor is: ",divisor.to.print)
# make the dividend the maximum of the two numbers
dividend <- max(a,60)
repeat
{
# save the remainder of dividend divided by divisor
remainder <- dividend %% divisor
# set the dividend as the divisor
dividend <- divisor
# make the divisor the remainder
divisor <- remainder
# if the remainder is not zero, then break, else keep going
if (remainder == 0)
{
cat( "The greatest common divisor is:", divisor.to.print)
}  break
}
}
gcd2 <- function(x)
{
# make divisor the minimum of the two numbers
divisor <- min(a,60)
# save divisor as divisor to print to use later.
divisor.to.print <- divisor
cat("The current divisor is: ",divisor.to.print)
# make the dividend the maximum of the two numbers
dividend <- max(a,60)
repeat
{
# save the remainder of dividend divided by divisor
remainder <- dividend %% divisor
# set the dividend as the divisor
dividend <- divisor
# make the divisor the remainder
divisor <- remainder
# if the remainder is not zero, then break, else keep going
if (remainder == 0)
{
cat( "The greatest common divisor is:")
}  break
}
}
gcd2 <- function(x)
{
# make divisor the minimum of the two numbers
divisor <- min(a,60)
# save divisor as divisor to print to use later.
divisor.to.print <- divisor
cat("The current divisor is: ",divisor.to.print)
# make the dividend the maximum of the two numbers
dividend <- max(a,60)
repeat
{
# save the remainder of dividend divided by divisor
remainder <- dividend %% divisor
# set the dividend as the divisor
dividend <- divisor
# make the divisor the remainder
divisor <- remainder
# if the remainder is not zero, then break, else keep going
if (remainder == 0)
{
cat( "The greatest common divisor is:")
}
}
}
gcd2 <- function(x)
{
# make divisor the minimum of the two numbers
divisor <- min(a,60)
# save divisor as divisor to print to use later.
divisor.to.print <- divisor
cat("The current divisor is: ",divisor.to.print)
# make the dividend the maximum of the two numbers
dividend <- max(a,60)
repeat
{
# save the remainder of dividend divided by divisor
remainder <- dividend %% divisor
# set the dividend as the divisor
dividend <- divisor
# make the divisor the remainder
divisor <- remainder
# if the remainder is not zero, then break, else keep going
if (remainder == 0) break
}
cat("The greatest common divisor is:")
}
gcd2(3)
gcd2 <- function(x)
{
# make divisor the minimum of the two numbers
divisor <- min(x,60)
# save divisor as divisor to print to use later.
divisor.to.print <- divisor
cat("The current divisor is: ",divisor.to.print)
# make the dividend the maximum of the two numbers
dividend <- max(x,60)
repeat
{
# save the remainder of dividend divided by divisor
remainder <- dividend %% divisor
# set the dividend as the divisor
dividend <- divisor
# make the divisor the remainder
divisor <- remainder
# if the remainder is not zero, then break, else keep going
if (remainder == 0) break
}
cat("The greatest common divisor is:")
}
gcd2(3)
gcd2 <- function(x)
{
# make divisor the minimum of the two numbers
divisor <- min(x,60)
# save divisor as divisor to print to use later.
divisor.to.print <- divisor
cat("The current divisor is: ",divisor.to.print)
# make the dividend the maximum of the two numbers
dividend <- max(x,60)
repeat
{
# save the remainder of dividend divided by divisor
remainder <- dividend %% divisor
# set the dividend as the divisor
dividend <- divisor
# make the divisor the remainder
divisor <- remainder
# if the remainder is not zero, then break, else keep going
if (remainder == 0) break
}
cat("The greatest common divisor is:")
}
gcd2(5)
gcd2 <- function(x)
{
# make divisor the minimum of the two numbers
divisor <- min(x,60)
# save divisor as divisor to print to use later.
divisor.to.print <- divisor
cat("The current divisor is: ",divisor.to.print)
# make the dividend the maximum of the two numbers
dividend <- max(x,60)
repeat
{
# save the remainder of dividend divided by divisor
remainder <- dividend %% divisor
# set the dividend as the divisor
dividend <- divisor
# make the divisor the remainder
divisor <- remainder
# if the remainder is not zero, then break, else keep going
if (remainder == 0) break
}
cat("The greatest common divisor is:")
}
gcd2(11)
gcd2 <- function(x)
{
# make divisor the minimum of the two numbers
divisor <- min(x,60)
# save divisor as divisor to print to use later.
divisor.to.print <- divisor
cat("The current divisor is: ",divisor.to.print)
# make the dividend the maximum of the two numbers
dividend <- max(x,60)
repeat
{
# save the remainder of dividend divided by divisor
remainder <- dividend %% divisor
# set the dividend as the divisor
dividend <- divisor
# make the divisor the remainder
divisor <- remainder
# if the remainder is not zero, then break, else keep going
if (remainder == 0) break
}
}
gcd2(11)
gcd <- function(a,b)
{
# make divisor the minimum of the two numbers
divisor <- min(a,b)
# make the dividend the maximum of the two numbers
dividend <- max(a,b)
repeat
{
# save the remainder of dividend divided by divisor
remainder <- dividend %% divisor
# set the dividend as the divisor
dividend <- divisor
# make the divisor the remainder
divisor <- remainder
# if the remainder is not zero, then break, else keep going
if (remainder == 0) break
}
}
# if they run and that is it, then the conditional loop took care of buisiness
gcd(6,15)
gcd2 <- function(a,b)
{
# make divisor the minimum of the two numbers
divisor <- min(a,b)
# save divisor as divisor to print to use later.
divisor.to.print <- divisor
cat("The current divisor is: ",divisor.to.print)
# make the dividend the maximum of the two numbers
dividend <- max(a,b)
repeat
{
# save the remainder of dividend divided by divisor
remainder <- dividend %% divisor
# set the dividend as the divisor
dividend <- divisor
# make the divisor the remainder
divisor <- remainder
# if the remainder is not zero, then break, else keep going
if (remainder == 0) break
}
}
gcd2(11,60)
gcd2(21,60)
gcd2 <- function(a)
{
for(i in range(1:a)) {
# make divisor the minimum of the two numbers
divisor <- min(a,b)
# make the dividend the maximum of the two numbers
dividend <- max(a,b)
repeat
{
# save the remainder of dividend divided by divisor
remainder <- dividend %% divisor
# set the dividend as the divisor
dividend <- divisor
# make the divisor the remainder
divisor <- remainder
# if the remainder is not zero, then break, else keep going
if (remainder == 0) break
}
# print the divident, which per the above is the divisor used for the ith element
cat(dividend,"\n")
}
}
gcd2(60)
gcd2 <- function(a)
{
for(i in range(1:a)) {
# make divisor the minimum of the two numbers
divisor <- min(i,60)
# make the dividend the maximum of the two numbers
dividend <- max(a,60)
repeat
{
# save the remainder of dividend divided by divisor
remainder <- dividend %% divisor
# set the dividend as the divisor
dividend <- divisor
# make the divisor the remainder
divisor <- remainder
# if the remainder is not zero, then break, else keep going
if (remainder == 0) break
}
# print the divident, which per the above is the divisor used for the ith element
cat(dividend,"\n")
}
}
gcd2(60)
gcd2 <- function(a)
{
for(i in range(1:a)) {
# make divisor the minimum of the two numbers
divisor <- min(i,60)
# make the dividend the maximum of the two numbers
dividend <- max(i,60)
repeat
{
# save the remainder of dividend divided by divisor
remainder <- dividend %% divisor
# set the dividend as the divisor
dividend <- divisor
# make the divisor the remainder
divisor <- remainder
# if the remainder is not zero, then break, else keep going
if (remainder == 0) break
}
# print the divident, which per the above is the divisor used for the ith element
cat(dividend,"\n")
}
}
gcd2(60)
gcd2(40)
gcd2(20)
gcd2(10)
freeflow <- 1
a <- .15
b <- 4
vol<-1
cap<-1
vc<-vol/cap
vc
freeflow(1+(a*(vc)^b))
freeflow*(1+(a*(vc)^b))
vol<.9
vol<-9
freeflow*(1+(a*(vc)^b))
vol<-.9
vc<-vol/cap
vc
freeflow*(1+(a*(vc)^b))
vol<-.5
vc<-vol/cap
freeflow*(1+(a*(vc)^b))
vol<-1
cap<-.5
vc<-vol/cap
freeflow*(1+(a*(vc)^b))
library(GISTools);data(tornados);library(geojsonio);library(rgdal);library(raster)
distances<-ft2miles(gDistances(places,gCentroid(blocks,byid=T,id=rownames(blocks))))
distances<-ft2miles(gDistance(places,gCentroid(blocks,byid=T,id=rownames(blocks))))
data(newhaven)
distances<-ft2miles(gDistance(places,gCentroid(blocks,byid=T,id=rownames(blocks))))
places@proj4string
blocks@proj4string
places@proj4string <- CRS("+proj=lcc +datum=NAD27 +lon_0=-72d45 +lat_1=41d52 +lat_2=41d12 +lat_0=40d50 +x_0=182880.3657607315
+y_0=0 +units=us-ft +no_defs +ellps=clrk66 +nadgrids=@conus,@alaska,@ntv2_0.gsb,@ntv1_can.dat ")
places@proj4string
places@proj4string <- blocks@proj4string
distances<-ft2miles(gDistance(places,gCentroid(blocks,byid=T,id=rownames(blocks))))
min.dist <- as.vector(apply(distance,1,min))
min.dist <- as.vector(apply(distances,1,min))
distances
ceontroids.<-gCentroid(blocks,byid=T,id=rownames(blocks))
centroids.<-gCentroid(blocks,byid=T,id=rownames(blocks))
distances<-ft2miles(gDistance(places,centroids.))
distances
proj4string(places) <- proj4string(blocks)
places<-spTransform(places,proj4string(blocks))
placesa
places
centroids.<-gCentroid(blocks,byid=T,id=rownames(blocks))
centroids.
distances<-ft2miles(gDistance(places,centroids.))
centroids.
blocks
blocks<-spTransform(blocks,proj4string(places))
blocks
places
centroids.<-gCentroid(blocks,byid=T,id=rownames(blocks))
# now get distances, which are distance from centroids to the places
distances<-ft2miles(gDistance(places,centroids.))
distances
distances<-ft2miles(gDistance(places,centroids.,byid=T))
distnacse
distnaces
distances
min.dist <- as.vector(apply(distances,1,min))
min.dist
access<-min.dist<1
access
ethnicity<-as.matrix(data.frame(blocks[,14:18]/100))
ethnicity<-as.matrix(data.frame(blocks[,14:18])/100))
ethnicity<-as.matrix(data.frame(blocks[,14:18])/100)
ethnicity<-apply(ethnicity,2,function(x) (x*blocks$POP1990))
ethnicity<-matrix(as.integer(enthnicity),ncols=5)
ethnicity<-matrix(as.integer(enthnicity),ncol=5)
ethnicity<-matrix(as.integer(ethnicity),ncol=5)
colnames(ethnicity)<-c("White","Black","Native American","Asian","Other")
mat.access.tab <- xtabs(ethnicity~access)
mat.access.tab
data.set<-as.data.frame(mat.access.tab);colnames(data.set)<-c('Access',"Ethnicity","Freq")
data.set
modelethnicity <- glm(Freq~Access*Ethnicity,data=data.set,family=poisson)
summary(modelethnicity)
summary(modelethnic)$coef
mod.coefs <- summary(modelethnic)$coef
summary(modelethnicity)$coef
mod.coefs <- summary(modelethnicity)$coef
mod.coefs
mosaicplot(t(mat.access.tab)),xlab='',ylab='Access to Supply',main="Moisaic Plot of Access",shade="TRUE",las=3,cex=0.8)
shade="TRUE",las=3,cex=0.8)
mosaicplot(t(mat.access.tab),
xlab='',ylab='Access to Supply',
main="Moisaic Plot of Access",
shade="TRUE",las=3,cex=0.8)
mosaicplot(t(mat.access.tab),
xlab='',ylab='Access to Supply',
main="Moisaic Plot of Access",
shade=TRUE,las=3,cex=0.8)
setwd("/Users/maxgrossman/Desktop/Tables/Other/ShapeFiles")
dc2010<-readOGR(".","DC_Census2000_v2")
library(rdgal)
library(Rdgal)
library(rgdal)
dc2010<-readOGR(".","DC_Census2000_v2")
setwd("/Users/maxgrossman/Desktop/Tables/FINAL_2000_2010")
DEC<-read.csv("dec00_variables_PCAresults.csv")
names(DEC)
DEC<-DEC[1:300,1:2]
DEC
DEC<-DEC[1:188,1:2]
DEC
write.csv("dec.ma2000.csv")
write.csv(DEC,"dec.ma2000.csv")
head(DEC)
